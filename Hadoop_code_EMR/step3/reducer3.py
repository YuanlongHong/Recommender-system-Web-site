# -*- coding: utf-8 -*-
"""Hadoop/reducer3.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/160S7i-dpKW1RCEK2ES5tx8ns1dotVxpq
"""

#!/usr/bin/env python3
import sys

# --- Reducer 3: 动态阈值筛选与 Top-K 聚合 ---
# 适用：User-Based 和 Item-Based
# 输入：MainID \t NeighborID:Sim:Count
# 输出：MainID \t Neighbor1:Sim,Neighbor2:Sim...

current_id = None
neighbors = []

# --- 配置 ---
K = 50
# 动态阈值：优先保留共同评分次数多的邻居
# 逻辑：先找 Count >= 5 的，不够再找 >= 4 的...
THRESHOLDS = [5, 4, 3, 2, 1]

def emit_result(main_id, neighbor_list):
    """
    执行筛选并输出 Top-K
    """
    # 1. 解析数据
    parsed_neighbors = []
    for n in neighbor_list:
        try:
            # n 的格式: "id:sim:count"
            parts = n.split(':')
            nid = parts[0]
            sim = float(parts[1])
            cnt = int(parts[2])
            parsed_neighbors.append({'id': nid, 'sim': sim, 'count': cnt})
        except (ValueError, IndexError):
            continue

    selected_candidates = None

    # 2. 动态阈值筛选逻辑
    for t in THRESHOLDS:
        # 筛选出 Count >= t 的邻居
        filtered = [x for x in parsed_neighbors if x['count'] >= t]

        # 如果数量足够 K 个，就停止降级，直接用这批高质量数据
        if len(filtered) >= K:
            selected_candidates = filtered
            break

    # 3. 兜底逻辑
    # 如果循环完了还没凑够 K 个（或者根本没几个邻居），就用最后一次筛选的结果或全部数据
    if selected_candidates is None:
        selected_candidates = parsed_neighbors

    # 4. 按相似度降序排序
    selected_candidates.sort(key=lambda x: x['sim'], reverse=True)

    # 5. 截取 Top K
    top_k = selected_candidates[:K]

    # 6. 格式化输出 (去除 Count，只保留 ID:Sim 给 Python 预测脚本用)
    out_list = [f"{x['id']}:{x['sim']}" for x in top_k]
    out_str = ",".join(out_list)

    # 最终输出: ID \t n1:0.9,n2:0.8...
    print(f"{main_id}\t{out_str}")

# --- 主循环 ---
for line in sys.stdin:
    line = line.strip()
    if not line:
        continue

    try:
        # 输入格式: MainID \t NeighborInfo
        id_val, neighbor_info = line.split("\t", 1)
    except ValueError:
        continue

    if current_id is None:
        current_id = id_val

    if id_val != current_id:
        emit_result(current_id, neighbors)
        current_id = id_val
        neighbors = []

    neighbors.append(neighbor_info)

# 处理最后一个组
if current_id is not None:
    emit_result(current_id, neighbors)